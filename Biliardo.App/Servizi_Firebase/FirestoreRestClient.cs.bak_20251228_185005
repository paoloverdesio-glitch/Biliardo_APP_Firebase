using System;
using System.Collections.Generic;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;

namespace Biliardo.App.Servizi_Firebase
{
    /// <summary>
    /// Client REST minimale per Cloud Firestore.
    /// Autenticazione: Authorization: Bearer {Firebase ID Token}
    /// Nota: con ID token, Firestore applica le Security Rules.
    /// </summary>
    public static class FirestoreRestClient
    {
        // === CONFIG ===
        // Preso dal google-services.json (project_info.project_id)
        private const string ProjectId = "biliardoapp";

        // Quasi sempre è (default). Se hai creato un DB con ID diverso, si cambia qui.
        private const string DatabaseId = "(default)";

        private static readonly HttpClient _http = new HttpClient
        {
            Timeout = TimeSpan.FromSeconds(25)
        };

        private static readonly JsonSerializerOptions JsonOpts = new(JsonSerializerDefaults.Web)
        {
            PropertyNameCaseInsensitive = true
        };

        private static string BaseDocumentsUrl =>
            $"https://firestore.googleapis.com/v1/projects/{ProjectId}/databases/{DatabaseId}/documents";

        // =========================================================
        // [1] API di base
        // =========================================================

        public static async Task<JsonDocument> GetDocumentAsync(string documentPath, string idToken, CancellationToken ct = default)
        {
            if (string.IsNullOrWhiteSpace(documentPath)) throw new ArgumentException("documentPath vuoto", nameof(documentPath));
            if (string.IsNullOrWhiteSpace(idToken)) throw new ArgumentException("idToken vuoto", nameof(idToken));

            var url = $"{BaseDocumentsUrl}/{documentPath.TrimStart('/')}";
            using var req = new HttpRequestMessage(HttpMethod.Get, url);
            req.Headers.Authorization = new AuthenticationHeaderValue("Bearer", idToken);

            using var resp = await _http.SendAsync(req, ct);
            var body = await resp.Content.ReadAsStringAsync(ct);

            if (!resp.IsSuccessStatusCode)
                throw new InvalidOperationException($"Firestore GET failed: {(int)resp.StatusCode}. {TryParseGoogleApiError(body) ?? body}");

            return JsonDocument.Parse(body);
        }

        public static async Task<JsonDocument> CreateDocumentAsync(
            string collectionPath,
            string? documentId,
            Dictionary<string, object> fields,
            string idToken,
            CancellationToken ct = default)
        {
            if (string.IsNullOrWhiteSpace(collectionPath)) throw new ArgumentException("collectionPath vuoto", nameof(collectionPath));
            if (fields == null) throw new ArgumentNullException(nameof(fields));
            if (string.IsNullOrWhiteSpace(idToken)) throw new ArgumentException("idToken vuoto", nameof(idToken));

            var baseUrl = $"{BaseDocumentsUrl}/{collectionPath.TrimStart('/')}";
            var url = string.IsNullOrWhiteSpace(documentId)
                ? baseUrl
                : $"{baseUrl}?documentId={Uri.EscapeDataString(documentId)}";

            var payload = new Dictionary<string, object>
            {
                ["fields"] = fields
            };

            using var req = new HttpRequestMessage(HttpMethod.Post, url);
            req.Headers.Authorization = new AuthenticationHeaderValue("Bearer", idToken);
            req.Content = new StringContent(JsonSerializer.Serialize(payload, JsonOpts), Encoding.UTF8, "application/json");

            using var resp = await _http.SendAsync(req, ct);
            var body = await resp.Content.ReadAsStringAsync(ct);

            if (!resp.IsSuccessStatusCode)
                throw new InvalidOperationException($"Firestore CREATE failed: {(int)resp.StatusCode}. {TryParseGoogleApiError(body) ?? body}");

            return JsonDocument.Parse(body);
        }

        public static async Task<JsonDocument> PatchDocumentAsync(
            string documentPath,
            Dictionary<string, object> fields,
            IReadOnlyList<string> updateMaskFieldPaths,
            string idToken,
            CancellationToken ct = default)
        {
            if (string.IsNullOrWhiteSpace(documentPath)) throw new ArgumentException("documentPath vuoto", nameof(documentPath));
            if (fields == null) throw new ArgumentNullException(nameof(fields));
            if (updateMaskFieldPaths == null || updateMaskFieldPaths.Count == 0) throw new ArgumentException("updateMask vuota", nameof(updateMaskFieldPaths));
            if (string.IsNullOrWhiteSpace(idToken)) throw new ArgumentException("idToken vuoto", nameof(idToken));

            var url = new StringBuilder($"{BaseDocumentsUrl}/{documentPath.TrimStart('/')}");
            for (int i = 0; i < updateMaskFieldPaths.Count; i++)
            {
                var p = updateMaskFieldPaths[i];
                if (string.IsNullOrWhiteSpace(p)) continue;
                url.Append(i == 0 ? "?" : "&");
                url.Append("updateMask.fieldPaths=");
                url.Append(Uri.EscapeDataString(p));
            }

            var payload = new Dictionary<string, object>
            {
                ["fields"] = fields
            };

            using var req = new HttpRequestMessage(HttpMethod.Patch, url.ToString());
            req.Headers.Authorization = new AuthenticationHeaderValue("Bearer", idToken);
            req.Content = new StringContent(JsonSerializer.Serialize(payload, JsonOpts), Encoding.UTF8, "application/json");

            using var resp = await _http.SendAsync(req, ct);
            var body = await resp.Content.ReadAsStringAsync(ct);

            if (!resp.IsSuccessStatusCode)
                throw new InvalidOperationException($"Firestore PATCH failed: {(int)resp.StatusCode}. {TryParseGoogleApiError(body) ?? body}");

            return JsonDocument.Parse(body);
        }

        // =========================================================
        // [2] Builder valori Firestore (fields)
        // =========================================================

        public static object VString(string value) => new Dictionary<string, object> { ["stringValue"] = value ?? "" };

        public static object VBool(bool value) => new Dictionary<string, object> { ["booleanValue"] = value };

        // Firestore REST vuole integerValue come stringa
        public static object VInt(long value) => new Dictionary<string, object> { ["integerValue"] = value.ToString() };

        public static object VTimestamp(DateTimeOffset utcTime)
        {
            var s = utcTime.ToUniversalTime().ToString("yyyy-MM-dd'T'HH:mm:ss.fff'Z'");
            return new Dictionary<string, object> { ["timestampValue"] = s };
        }

        public static object VArray(params object[] values)
        {
            var arr = new Dictionary<string, object>();
            if (values != null && values.Length > 0)
                arr["values"] = values;

            return new Dictionary<string, object>
            {
                ["arrayValue"] = arr
            };
        }

        public static object VArrayStrings(IEnumerable<string> strings)
        {
            var vals = new List<object>();
            foreach (var s in strings)
                vals.Add(VString(s));

            return VArray(vals.ToArray());
        }

        public static object VNull() => new Dictionary<string, object> { ["nullValue"] = "NULL_VALUE" };

        // =========================================================
        // [3] Parse error Google APIs
        // =========================================================

        private static string? TryParseGoogleApiError(string body)
        {
            try
            {
                using var doc = JsonDocument.Parse(body);
                if (doc.RootElement.ValueKind != JsonValueKind.Object) return null;

                if (doc.RootElement.TryGetProperty("error", out var err) && err.ValueKind == JsonValueKind.Object)
                {
                    string? status = null;
                    string? message = null;

                    if (err.TryGetProperty("status", out var st) && st.ValueKind == JsonValueKind.String)
                        status = st.GetString();

                    if (err.TryGetProperty("message", out var msg) && msg.ValueKind == JsonValueKind.String)
                        message = msg.GetString();

                    if (!string.IsNullOrWhiteSpace(status) || !string.IsNullOrWhiteSpace(message))
                        return $"{status ?? "ERROR"}: {message ?? ""}".Trim();
                }
            }
            catch
            {
                // ignore
            }
            return null;
        }
    }
}
